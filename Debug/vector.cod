; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29912.0 

	TITLE	C:\Users\Administrator\Desktop\carsales project\carsales project\Debug\vector.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__94F4CCDD_vector@c DB 01H
msvcjmc	ENDS
PUBLIC	_vector_init
PUBLIC	_vector_total
PUBLIC	_vector_add
PUBLIC	_vector_set
PUBLIC	_vector_get
PUBLIC	_vector_delete
PUBLIC	_vector_free
PUBLIC	__JustMyCode_Default
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__realloc:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Administrator\Desktop\carsales project\carsales project\vector.c
;	COMDAT _vector_free
_TEXT	SEGMENT
_v$ = 8							; size = 4
_vector_free PROC					; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __94F4CCDD_vector@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 74   :     free(v->items);

  00028	8b f4		 mov	 esi, esp
  0002a	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	51		 push	 ecx
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00036	83 c4 04	 add	 esp, 4
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 75   : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
_vector_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Administrator\Desktop\carsales project\carsales project\vector.c
;	COMDAT _vector_delete
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_v$ = 8							; size = 4
_index$ = 12						; size = 4
_vector_delete PROC					; COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __94F4CCDD_vector@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 56   :     if (index < 0 || index >= v->total)

  00028	83 7d 0c 00	 cmp	 DWORD PTR _index$[ebp], 0
  0002c	7c 0b		 jl	 SHORT $LN6@vector_del
  0002e	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _index$[ebp]
  00034	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00037	7c 05		 jl	 SHORT $LN5@vector_del
$LN6@vector_del:

; 57   :         return;

  00039	e9 9e 00 00 00	 jmp	 $LN1@vector_del
$LN5@vector_del:

; 58   : 
; 59   :     v->items[index] = NULL;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	8b 55 0c	 mov	 edx, DWORD PTR _index$[ebp]
  00046	c7 04 91 00 00
	00 00		 mov	 DWORD PTR [ecx+edx*4], 0

; 60   : 
; 61   :     for (int i = index; i < v->total - 1; i++) {

  0004d	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
  00053	eb 09		 jmp	 SHORT $LN4@vector_del
$LN2@vector_del:
  00055	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00058	83 c0 01	 add	 eax, 1
  0005b	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@vector_del:
  0005e	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00061	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00064	83 e9 01	 sub	 ecx, 1
  00067	39 4d f8	 cmp	 DWORD PTR _i$1[ebp], ecx
  0006a	7d 29		 jge	 SHORT $LN3@vector_del

; 62   :         v->items[i] = v->items[i + 1];

  0006c	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0006f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00071	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00074	8b 02		 mov	 eax, DWORD PTR [edx]
  00076	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  00079	8b 75 f8	 mov	 esi, DWORD PTR _i$1[ebp]
  0007c	8b 4c b1 04	 mov	 ecx, DWORD PTR [ecx+esi*4+4]
  00080	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 63   :         v->items[i + 1] = NULL;

  00083	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  0008b	c7 44 91 04 00
	00 00 00	 mov	 DWORD PTR [ecx+edx*4+4], 0

; 64   :     }

  00093	eb c0		 jmp	 SHORT $LN2@vector_del
$LN3@vector_del:

; 65   : 
; 66   :     v->total--;

  00095	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00098	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009b	83 e9 01	 sub	 ecx, 1
  0009e	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  000a1	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 67   : 
; 68   :     if (v->total > 0 && v->total == v->capacity / 4)

  000a4	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  000a7	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000ab	7e 2f		 jle	 SHORT $LN1@vector_del
  000ad	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  000b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b3	99		 cdq
  000b4	83 e2 03	 and	 edx, 3
  000b7	03 c2		 add	 eax, edx
  000b9	c1 f8 02	 sar	 eax, 2
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  000bf	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  000c2	75 18		 jne	 SHORT $LN1@vector_del

; 69   :         vector_resize(v, v->capacity / 2);

  000c4	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  000c7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ca	99		 cdq
  000cb	2b c2		 sub	 eax, edx
  000cd	d1 f8		 sar	 eax, 1
  000cf	50		 push	 eax
  000d0	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 _vector_resize
  000d9	83 c4 08	 add	 esp, 8
$LN1@vector_del:

; 70   : }

  000dc	5f		 pop	 edi
  000dd	5e		 pop	 esi
  000de	5b		 pop	 ebx
  000df	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000e5	3b ec		 cmp	 ebp, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
_vector_delete ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Administrator\Desktop\carsales project\carsales project\vector.c
;	COMDAT _vector_get
_TEXT	SEGMENT
_v$ = 8							; size = 4
_index$ = 12						; size = 4
_vector_get PROC					; COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __94F4CCDD_vector@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 49   :     if (index >= 0 && index < v->total)

  00028	83 7d 0c 00	 cmp	 DWORD PTR _index$[ebp], 0
  0002c	7c 18		 jl	 SHORT $LN2@vector_get
  0002e	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _index$[ebp]
  00034	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00037	7d 0d		 jge	 SHORT $LN2@vector_get

; 50   :         return v->items[index];

  00039	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _index$[ebp]
  00041	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  00044	eb 02		 jmp	 SHORT $LN1@vector_get
$LN2@vector_get:

; 51   :     return NULL;

  00046	33 c0		 xor	 eax, eax
$LN1@vector_get:

; 52   : }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
_vector_get ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Administrator\Desktop\carsales project\carsales project\vector.c
;	COMDAT _vector_set
_TEXT	SEGMENT
_v$ = 8							; size = 4
_index$ = 12						; size = 4
_item$ = 16						; size = 4
_vector_set PROC					; COMDAT

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __94F4CCDD_vector@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   :     if (index >= 0 && index < v->total)

  00028	83 7d 0c 00	 cmp	 DWORD PTR _index$[ebp], 0
  0002c	7c 19		 jl	 SHORT $LN1@vector_set
  0002e	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _index$[ebp]
  00034	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00037	7d 0e		 jge	 SHORT $LN1@vector_set

; 44   :         v->items[index] = item;

  00039	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	8b 55 0c	 mov	 edx, DWORD PTR _index$[ebp]
  00041	8b 45 10	 mov	 eax, DWORD PTR _item$[ebp]
  00044	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
$LN1@vector_set:

; 45   : }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_vector_set ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Administrator\Desktop\carsales project\carsales project\vector.c
;	COMDAT _vector_add
_TEXT	SEGMENT
_v$ = 8							; size = 4
_item$ = 12						; size = 4
_vector_add PROC					; COMDAT

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __94F4CCDD_vector@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 34   :     if (item != NULL) {

  00028	83 7d 0c 00	 cmp	 DWORD PTR _item$[ebp], 0
  0002c	74 43		 je	 SHORT $LN1@vector_add

; 35   :         if (v->capacity == v->total)

  0002e	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00034	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00037	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003a	75 15		 jne	 SHORT $LN3@vector_add

; 36   :             vector_resize(v, v->capacity * 2);

  0003c	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0003f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00042	d1 e1		 shl	 ecx, 1
  00044	51		 push	 ecx
  00045	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 _vector_resize
  0004e	83 c4 08	 add	 esp, 8
$LN3@vector_add:

; 37   :         v->items[v->total++] = item;

  00051	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00054	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00057	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  0005a	8b 02		 mov	 eax, DWORD PTR [edx]
  0005c	8b 55 0c	 mov	 edx, DWORD PTR _item$[ebp]
  0005f	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  00062	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00065	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00068	83 c1 01	 add	 ecx, 1
  0006b	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  0006e	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
$LN1@vector_add:

; 38   :     }
; 39   : }

  00071	5f		 pop	 edi
  00072	5e		 pop	 esi
  00073	5b		 pop	 ebx
  00074	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0007a	3b ec		 cmp	 ebp, esp
  0007c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_vector_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Administrator\Desktop\carsales project\carsales project\vector.c
;	COMDAT _vector_resize
_TEXT	SEGMENT
_items$ = -8						; size = 4
_v$ = 8							; size = 4
_capacity$ = 12						; size = 4
_vector_resize PROC					; COMDAT

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __94F4CCDD_vector@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 21   : #ifdef DEBUG_ON
; 22   :     printf("vector_resize: %d to %d\n", v->capacity, capacity);
; 23   : #endif
; 24   : 
; 25   :     void** items = realloc(v->items, sizeof(void*) * capacity);

  00028	33 c9		 xor	 ecx, ecx
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _capacity$[ebp]
  0002d	ba 04 00 00 00	 mov	 edx, 4
  00032	f7 e2		 mul	 edx
  00034	0f 90 c1	 seto	 cl
  00037	f7 d9		 neg	 ecx
  00039	0b c8		 or	 ecx, eax
  0003b	8b f4		 mov	 esi, esp
  0003d	51		 push	 ecx
  0003e	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	51		 push	 ecx
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  0004a	83 c4 08	 add	 esp, 8
  0004d	3b f4		 cmp	 esi, esp
  0004f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00054	89 45 f8	 mov	 DWORD PTR _items$[ebp], eax

; 26   :     if (items) {

  00057	83 7d f8 00	 cmp	 DWORD PTR _items$[ebp], 0
  0005b	74 11		 je	 SHORT $LN1@vector_res

; 27   :         v->items = items;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00060	8b 4d f8	 mov	 ecx, DWORD PTR _items$[ebp]
  00063	89 08		 mov	 DWORD PTR [eax], ecx

; 28   :         v->capacity = capacity;

  00065	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00068	8b 4d 0c	 mov	 ecx, DWORD PTR _capacity$[ebp]
  0006b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN1@vector_res:

; 29   :     }
; 30   : }

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00077	3b ec		 cmp	 ebp, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_vector_resize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Administrator\Desktop\carsales project\carsales project\vector.c
;	COMDAT _vector_total
_TEXT	SEGMENT
_v$ = 8							; size = 4
_vector_total PROC					; COMDAT

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __94F4CCDD_vector@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 16   :     return v->total;

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 17   : }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_vector_total ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\Administrator\Desktop\carsales project\carsales project\vector.c
;	COMDAT _vector_init
_TEXT	SEGMENT
_v$ = 8							; size = 4
_vector_init PROC					; COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __94F4CCDD_vector@c
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 9    :     v->capacity = VECTOR_INIT_CAPACITY;

  00028	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  0002b	c7 40 04 04 00
	00 00		 mov	 DWORD PTR [eax+4], 4

; 10   :     v->total = 0;

  00032	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00035	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 11   :     v->items = malloc(sizeof(void*) * v->capacity);

  0003c	33 c9		 xor	 ecx, ecx
  0003e	8b 55 08	 mov	 edx, DWORD PTR _v$[ebp]
  00041	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00044	ba 04 00 00 00	 mov	 edx, 4
  00049	f7 e2		 mul	 edx
  0004b	0f 90 c1	 seto	 cl
  0004e	f7 d9		 neg	 ecx
  00050	0b c8		 or	 ecx, eax
  00052	8b f4		 mov	 esi, esp
  00054	51		 push	 ecx
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0005b	83 c4 04	 add	 esp, 4
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00068	89 01		 mov	 DWORD PTR [ecx], eax

; 12   : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
_vector_init ENDP
_TEXT	ENDS
END
